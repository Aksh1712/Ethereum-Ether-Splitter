// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract EtherSplitter is Ownable, ReentrancyGuard {
    address payable[3] public recipients;
    mapping(address => uint256) public pendingRefunds;

    event EtherReceived(address indexed sender, uint256 amount);
    event EtherSplit(address indexed sender, uint256 amountPerRecipient, uint256 remainder);
    event RefundWithdrawn(address indexed recipient, uint256 amount);

    constructor(address payable _recipient1, address payable _recipient2, address payable _recipient3) Ownable(msg.sender) {
        require(_recipient1 != address(0) && _recipient2 != address(0) && _recipient3 != address(0), "Invalid recipient address");
        recipients[0] = _recipient1;
        recipients[1] = _recipient2;
        recipients[2] = _recipient3;
    }

    function splitEther() public payable nonReentrant {
        require(msg.value > 0, "Must send Ether");
        uint256 amountPerRecipient = msg.value / 3;
        uint256 remainder = msg.value % 3;

        emit EtherReceived(msg.sender, msg.value);

        for (uint256 i = 0; i < 3; i++) {
            if (amountPerRecipient > 0) {
                recipients[i].transfer(amountPerRecipient);
            }
        }

        if (remainder > 0) {
            pendingRefunds[msg.sender] += remainder;
        }

        emit EtherSplit(msg.sender, amountPerRecipient, remainder);
    }

    function withdrawRefund() public nonReentrant returns (bool) {
        uint256 amount = pendingRefunds[msg.sender];
        require(amount > 0, "No refund available");

        pendingRefunds[msg.sender] = 0;
        if (!payable(msg.sender).send(amount)) {
            pendingRefunds[msg.sender] = amount;
            return false;
        }
        emit RefundWithdrawn(msg.sender, amount);
        return true;
    }

    function getRecipients() public view returns (address payable[3] memory) {
        return recipients;
    }

    function getContractBalance() public view returns (uint256) {
        return address(this).balance;
    }

    function updateRecipient(uint256 index, address payable newRecipient) public onlyOwner {
        require(index < 3, "Invalid recipient index");
        require(newRecipient != address(0), "Invalid recipient address");
        recipients[index] = newRecipient;
    }
}